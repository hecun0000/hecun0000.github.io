(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{335:function(v,_,t){"use strict";t.r(_);var a=t(0),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[v._v("#")]),v._v(" 浏览器缓存")]),v._v(" "),t("h2",{attrs:{id:"简要介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简要介绍"}},[v._v("#")]),v._v(" 简要介绍")]),v._v(" "),t("p",[v._v("浏览器缓存存在于服务器和客户端之间。浏览器缓存密切注视着服务器-客户端之间的通信，监控请求，并且把请求输出的内容（例如html页面、 图片和文件）另存一份；然后，如果下一个请求是相同的URL，则直接使用保存的副本，而不是再次请求源服务器。")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://static.hecun.site/hecun158916811371268.png",alt:"浏览器缓存.png"}})]),v._v(" "),t("h3",{attrs:{id:"浏览器缓存的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存的优点"}},[v._v("#")]),v._v(" 浏览器缓存的优点")]),v._v(" "),t("ul",[t("li",[v._v("减少网络延迟，提升页面加载速度")]),v._v(" "),t("li",[v._v("降低服务器压力")]),v._v(" "),t("li",[v._v("减少网络带宽损耗")])]),v._v(" "),t("h3",{attrs:{id:"浏览器缓存的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存的缺点"}},[v._v("#")]),v._v(" 浏览器缓存的缺点")]),v._v(" "),t("ul",[t("li",[v._v("缓存没有清理机制")]),v._v(" "),t("li",[v._v("给开发带来的困扰")])]),v._v(" "),t("h2",{attrs:{id:"缓存的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存的过程"}},[v._v("#")]),v._v(" 缓存的过程")]),v._v(" "),t("p",[v._v("浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。具体看下图。")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://static.hecun.site/hecun158903372631656.png",alt:"162db6359673e7d0.png"}})]),v._v(" "),t("p",[v._v("根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。")]),v._v(" "),t("h2",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),t("p",[v._v("在 "),t("code",[v._v("HTTP/1.0")]),v._v(" 和"),t("code",[v._v("HTTP/1.1")]),v._v(" 当中，这个字段是不一样的。在早期，也就是 "),t("code",[v._v("HTTP/1.0")]),v._v(" 时期，使用的是Expires，而 "),t("code",[v._v("HTTP/1.1")]),v._v(" 使用的是 "),t("code",[v._v("Cache-Control")]),v._v(" 。")]),v._v(" "),t("h3",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[v._v("#")]),v._v(" Expires")]),v._v(" "),t("p",[t("code",[v._v("Expires")]),v._v(" 即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，不需要再次请求。")]),v._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[v._v("Expires"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" Wed"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("22")]),v._v(" May "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("2020")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("07")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("11")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("00")]),v._v(" GMT\n")])])]),t("p",[v._v("当首部字段 "),t("code",[v._v("Cache-Control")]),v._v(" 有指定 "),t("code",[v._v("max-age")]),v._v(" 指令 时，则优先处理 "),t("code",[v._v("max-age")]),v._v(" 指令")]),v._v(" "),t("p",[v._v("但是有个潜在问题，服务器时间和浏览器的时间不一致，导致出现问题。在 "),t("code",[v._v("HTTP/1.1")]),v._v(" 中已经被抛弃。")]),v._v(" "),t("h3",{attrs:{id:"cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[v._v("#")]),v._v(" Cache-Control")]),v._v(" "),t("p",[v._v("用于请求以及响应时。可添加多个指令。 多个指令使用 “,” 分隔。")]),v._v(" "),t("ul",[t("li",[v._v("缓存请求指令")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("指令")]),v._v(" "),t("th",[v._v("参数")]),v._v(" "),t("th",[v._v("说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("no-cache")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("强制向服务器再次验证")])]),v._v(" "),t("tr",[t("td",[v._v("no-store")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("不缓存请求或响应的任何内容")])]),v._v(" "),t("tr",[t("td",[v._v("max-age = [秒]")]),v._v(" "),t("td",[v._v("必需")]),v._v(" "),t("td",[v._v("响应的最大Age值")])]),v._v(" "),t("tr",[t("td",[v._v("max-stale( = [秒])")]),v._v(" "),t("td",[v._v("可省略")]),v._v(" "),t("td",[v._v("接收已过期的响应")])]),v._v(" "),t("tr",[t("td",[v._v("min-fresh = [秒]")]),v._v(" "),t("td",[v._v("必需")]),v._v(" "),t("td",[v._v("期望在指定时间内的响应仍有效")])]),v._v(" "),t("tr",[t("td",[v._v("no-transform")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("代理不可更改媒体类型")])]),v._v(" "),t("tr",[t("td",[v._v("only-if-cached")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("从缓存中获取资源")])]),v._v(" "),t("tr",[t("td",[v._v("cached-extension")]),v._v(" "),t("td",[v._v("-")]),v._v(" "),t("td",[v._v("新指令标记（token）")])])])]),v._v(" "),t("ul",[t("li",[v._v("缓存响应指令")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("指令")]),v._v(" "),t("th",[v._v("参数")]),v._v(" "),t("th",[v._v("说明")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("public")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("可向任意方向提供响应的缓存")])]),v._v(" "),t("tr",[t("td",[v._v("private")]),v._v(" "),t("td",[v._v("可省略")]),v._v(" "),t("td",[v._v("仅向特定用于返回响应")])]),v._v(" "),t("tr",[t("td",[v._v("no-cache")]),v._v(" "),t("td",[v._v("可省略")]),v._v(" "),t("td",[v._v("缓存前必须先确认其有效性")])]),v._v(" "),t("tr",[t("td",[v._v("no-store")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("不缓存请求或响应的任何内容")])]),v._v(" "),t("tr",[t("td",[v._v("no-transform")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("代理不可更改媒体类型")])]),v._v(" "),t("tr",[t("td",[v._v("must-revalidate")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("可缓存但必须再向源服务器进行确认")])]),v._v(" "),t("tr",[t("td",[v._v("proxy-revalidate")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("要求中间缓存服务器对缓存的响应有效性再进行确认")])]),v._v(" "),t("tr",[t("td",[v._v("max-age = [秒]")]),v._v(" "),t("td",[v._v("必需")]),v._v(" "),t("td",[v._v("响应的最大Age值")])]),v._v(" "),t("tr",[t("td",[v._v("s-maxage = [秒]")]),v._v(" "),t("td",[v._v("必需")]),v._v(" "),t("td",[v._v("公共缓存服务器响应的最大Age值")])]),v._v(" "),t("tr",[t("td",[v._v("cached-extension")]),v._v(" "),t("td",[v._v("-")]),v._v(" "),t("td",[v._v("新指令标记（token）")])])])]),v._v(" "),t("p",[v._v("比如：")]),v._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 响应返回后在 3600 秒, 直接使用缓存")]),v._v("\nCache"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("Control"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("max"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("age"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("3600")]),v._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 其他用户也可以利用缓存")]),v._v("\nCache"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("Control"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" pulic \n")])])]),t("p",[v._v("当强缓存失效的话就进行下一步协商缓存。")]),v._v(" "),t("h2",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),t("p",[v._v("强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。")]),v._v(" "),t("p",[v._v("具体来说，这样的缓存tag分为两种: "),t("code",[v._v("Last-Modified")]),v._v(" 和 "),t("code",[v._v("ETag")]),v._v(" 。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样。")]),v._v(" "),t("h3",{attrs:{id:"last-modified"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[v._v("#")]),v._v(" Last-Modified")]),v._v(" "),t("p",[v._v("即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。")]),v._v(" "),t("p",[v._v("浏览器接收到后，如果再次请求，会在请求头中携带 "),t("code",[v._v("If-Modified-Since")]),v._v(" 字段，这个字段的值也就是服务器传来的最后修改时间。")]),v._v(" "),t("p",[v._v("服务器拿到请求头中的 "),t("code",[v._v("If-Modified-Since")]),v._v(" 的字段后，其实会和这个服务器中该资源的最后修改时间对比:")]),v._v(" "),t("p",[v._v("如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。\n否则返回304，告诉浏览器直接用缓存。")]),v._v(" "),t("h3",{attrs:{id:"etag"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[v._v("#")]),v._v(" ETag")]),v._v(" "),t("p",[v._v("ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。")]),v._v(" "),t("p",[v._v("浏览器接收到 "),t("code",[v._v("ETag")]),v._v(" 的值，会在下次请求时，将这个值作为 "),t("code",[v._v("If-None-Match")]),v._v(" 这个字段的内容，并放到请求头中，然后发给服务器。")]),v._v(" "),t("p",[v._v("服务器接收到 "),t("code",[v._v("If-None-Match")]),v._v(" 后，会跟服务器上该资源的 "),t("code",[v._v("ETag")]),v._v(" 进行比对:")]),v._v(" "),t("p",[v._v("如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。\n否则返回304，告诉浏览器直接用缓存。")]),v._v(" "),t("h3",{attrs:{id:"两者对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两者对比"}},[v._v("#")]),v._v(" 两者对比")]),v._v(" "),t("p",[v._v("在精准度上，"),t("code",[v._v("ETag")]),v._v(" 优于 "),t("code",[v._v("Last-Modified")]),v._v(" 。优于 "),t("code",[v._v("ETag")]),v._v(" 是按照内容给资源上标识，因此能准确感知资源的变化。而 "),t("code",[v._v("Last-Modified")]),v._v(" 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:\n编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。")]),v._v(" "),t("p",[t("code",[v._v("Last-Modified")]),v._v(" 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 "),t("code",[v._v("Last-Modified")]),v._v(" 并没有体现出修改了。")]),v._v(" "),t("p",[v._v("在性能上，"),t("code",[v._v("Last-Modified")]),v._v(" 优于 "),t("code",[v._v("ETag")]),v._v("，也很简单理解，"),t("code",[v._v("Last-Modified")]),v._v(" 仅仅只是记录一个时间点，而 "),t("code",[v._v("Etag")]),v._v(" 需要根据文件的具体内容生成哈希值。\n另外，如果两种方式都支持的话，服务器会优先考虑 "),t("code",[v._v("ETag")]),v._v(" 。")]),v._v(" "),t("h2",{attrs:{id:"缓存位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[v._v("#")]),v._v(" 缓存位置")]),v._v(" "),t("p",[v._v("当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？")]),v._v(" "),t("p",[v._v("浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：")]),v._v(" "),t("ul",[t("li",[v._v("Service Worker")]),v._v(" "),t("li",[v._v("Memory Cache")]),v._v(" "),t("li",[v._v("Disk Cache")]),v._v(" "),t("li",[v._v("Push Cache")])]),v._v(" "),t("h3",{attrs:{id:"service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[v._v("#")]),v._v(" Service Worker")]),v._v(" "),t("p",[t("code",[v._v("Service Worker")]),v._v(" 借鉴了 "),t("code",[v._v("Web Worker")]),v._v(" 的 思路，即让 "),t("code",[v._v("JS")]),v._v(" 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 "),t("code",[v._v("DOM")]),v._v(" 。虽然如此，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 "),t("code",[v._v("Service Worker Cache")]),v._v("。")]),v._v(" "),t("p",[t("code",[v._v("Service Worker")]),v._v(" 同时也是 "),t("code",[v._v("PWA")]),v._v(" 的重要实现机制。")]),v._v(" "),t("h3",{attrs:{id:"memory-cache-和-disk-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache-和-disk-cache"}},[v._v("#")]),v._v(" Memory Cache 和 Disk Cache")]),v._v(" "),t("p",[v._v("Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://static.hecun.site/hecun158911525402436.png",alt:"微信截图_20200510205356.png"}})]),v._v(" "),t("p",[t("code",[v._v("Disk Cache")]),v._v(" 就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。")]),v._v(" "),t("p",[v._v("好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？")]),v._v(" "),t("p",[v._v("主要策略如下：")]),v._v(" "),t("ol",[t("li",[v._v("比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存")]),v._v(" "),t("li",[v._v("内存使用率比较高的时候，文件优先进入磁盘")])]),v._v(" "),t("h3",{attrs:{id:"push-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[v._v("#")]),v._v(" Push Cache")]),v._v(" "),t("p",[v._v("即推送缓存，是 HTTP/2 中的内容，目前应用的还不是很广泛，就不介绍了。")])])}),[],!1,null,null,null);_.default=e.exports}}]);